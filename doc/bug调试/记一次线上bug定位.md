#记一次线上bug定位 

##背景
项目中有一个每天凌晨将统计数据入库的定时器，以供运营人员查询。某段时间因部署项目问题，出现数据库插入数据主键重复异常，之后出现了我遇到的这个奇怪的问题。

##排查
首先问题定位到因为在一个环境部署了相同的两个项目，导致凌晨有两个定时器插入相同数据。对重复项目做了清理之后，认为问题已不存在，没有主动验证，导致第二天的定时器执行依旧出错。

##进一步排查
获取sql日志，对插入数据进行分析，发现日期参数很混乱。理论上每天的入库数据的时间戳应该都为前一天的年月日格式，但是线上的数据日期不符合预期:
```
Parameters: ... 20170119(String), ... 20170119(String), ... 20170122(String), ... 20170207(String), ... 20170122(String), ...  20170128(String), ... 20170202(String), ... 20170120(String), ...
    ps:隐去不必要数据
```
而时间戳是代码生成的，并且通过业务逻辑和前置日志的判断得出，时间戳生成无误。
通过开放的接口手动调用定时器方法，发现该问题必现，且出错问题数据一致。对时间戳进行分析，找到的规律是时间戳均在预期时间戳之前，并且最早的时间戳大致在部署问题开始日期。
这时有点灵感了，因为代码中为了批量插入mysql，减少数据库连接频繁获取和连接，我对插入数据进行了缓存。当满足一些情况，才调用持久化方法，再清空缓存map。现有问题很可能是因为某些原因缓存map未清空，然后我定位了清空map的代码：
```java
```
如上所示，第一行进行批量插入时抛出异常，导致接下去的map.clear()并未执行。而该map是类的静态变量，有问题的缓存数据将一直存在。

##问题解决
既然问题已经定位，那么解决办法就简单了，我给出了两个方案：
1.将map.clear()方法放入异常的finally区块，以保证缓存数据的清除。
2.将map定义在定时的方法中，每次定时器调用时才进行声明和实例化。
